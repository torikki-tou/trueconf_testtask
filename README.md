## How to run

`docker-compose up`

- Порт 8000 — API
- Порт 15672 — RabbitMQ management

## Описание изменений

Итак, я выполнил тестовое задание и сейчас расскажу какие изменения я внёс и самое главное зачем.

Начал я с мелких фиксов: заменил deprecated функции, обновил название модуля и версию языка, исправил некоторые названия.

Основное изменение, которое я внёс — архитектура handler-service-repository. Бизнес логика сосредоточена в слое сервиса, именно там должны происходить все необходимые проверки, обращения к сторонним апи тд. и тп. Слой хендлера отвечает исключительно за прием сообщения и его извлечение. Репозиторий напрямую работает с данными. Такой подход позволит при необходимости заменить хендлер и репозиторий на что-то другое, не внося изменений в основную логику, это снижает вероятность ошибок. Данные можно будет принимать не через REST, а по gRPC или из очереди. Ну и сохранение в файле очевидно сменится на любую БД. Также в различных сервисах можно будет инкапсулировать работу с новыми объектами, появление которых анонсировано в задании.

Также я считаю важным создание отдельного пакета Data Transfer Objects (DTO). Там теперь хранятся структуры тех сущностей, которые планируется получить на вход или отправить куда либо. Для входящих запросов добавлена валидация!

Когда я структурировал приложение и реализовал все необходимые по моему мнению на данном этапе фичи, пришло время Docker. Билд в несколько стадий снижает вес образа с 300 Мб до 16, docker-compose прилагается.

На этом этапе можно было бы закончить, но у меня оставалось время и я решил ещё немного поиграться, тем более это не настоящий проект, где время для бизнеса = деньги. Так вот, после всевозможных манипуляций с аккаунтом обычно принято отправлять уведомления на условный имейл, поэтому я решил добавить к проекту RabbitMQ, тем более что в докере это делается в 2 клика. Кроме репозитория, сохраняющего в файл теперь есть репозиторий для уведомлений. После создания, изменения или удаления аккаунта информация об этом событии уходит в очередь, где это сообщение может подобрать сервис уведомлений/email-рассылок. В соответствии с архитектурой эта логика отражена в сервисе, а вот очередь можно при желании поменять.

Под конец хочу сказать спасибо за такое интересное тестовое, нестандартный подход к таким вещам сразу повышает интерес к Вашей компании. Надеюсь вы меня возьмёте!

## Задание

Здравствуйте, %USERNAME%!

Вам предстоит выполнить рефакторинг небольшого приложения на Go (200 строк).

Приложение представляет собой API по работе с сущностью User, где хранилищем выступает файл json.

Ограничения:
- Хранилищем должен оставаться файл в json формате.
- Структура пользователя не должна быть уменьшена.
- Приложение не должно потерять существующую функциональность. 

Мы понимаем, что пределу совершенства нет и ожидаем, что объем рефакторинга вы определяете на свое усмотрение.  

После того как вы выполните задание, вы так же можете написать, как бы улучшили проект в перспективе текстом.

Что следует знать:
- В будущем это приложение ожидает увеличение количества функций и сущностей. 
- Вопрос авторизации умышленно опущен, о нем не стоит беспокоиться.
- API еще не выпущено, вы в праве скорректировать интерфейс / форматы ответов.

Работа должна быть оформлена на Github.

Удачи!
